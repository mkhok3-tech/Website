<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Infinite Platformer — Demo</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1020;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    #game{display:block;margin:0 auto;background:linear-gradient(#1b2a47,#081226);box-shadow:0 10px 30px rgba(0,0,0,0.6);border-radius:8px}
    .hud{position:fixed;left:20px;top:20px;font-weight:600;letter-spacing:0.6px}
    .controls{position:fixed;right:20px;top:20px;text-align:right;color:#dfe9ff85}
    .hint{position:fixed;left:50%;bottom:20px;transform:translateX(-50%);color:#cfe;opacity:0.9}
    button{appearance:none;background:#2b3b6a;border:0;padding:8px 12px;border-radius:6px;color:white;cursor:pointer}
  </style>
</head>
<body>
  <canvas id="game" width="1200" height="650"></canvas>
  <div class="hud" id="hud">Score: 0</div>
  <div class="controls">Arrows / A D to move • W / Up to jump • Space to dash</div>
  <div class="hint">Mobile: Touch left/right half to move, swipe up to jump</div>

<script>
/*
 Infinite Platformer
 - Single-file HTML + JS game that generates an endless world of platforms
 - Features: player physics, double jump, dash, moving platforms, enemies, collectibles
 - Procedural generation: platforms generat red ahead of player, cleaned up behind
 - Camera follows player; score increases with distance
 - Controls: keyboard + basic mobile touch gestures
*/

// ----- Config -----
const CONFIG = {
  gravity: 2200,
  player: {w:48,h:64, speed: 420, jumpSpeed: 820, dashSpeed: 900, dashDuration: 0.12, maxJumps:2},
  platformMinGap: 80,
  platformMaxGap: 360,
  platformMinWidth: 90,
  platformMaxWidth: 420,
  platformYVariance: 200,
  seed: Math.floor(Math.random()*1e9)
};

// ----- Utilities -----
function rand(seededRange){
  // seededRange: {min,max,seed?}
  return Math.random()*(seededRange.max-seededRange.min)+seededRange.min;
}
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

// ----- Canvas & Input -----
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;
window.addEventListener('resize', ()=>{ /* keep fixed size for deterministic layout */ });

const keys = {};
window.addEventListener('keydown', e=>{keys[e.key.toLowerCase()] = true; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();});
window.addEventListener('keyup', e=>{keys[e.key.toLowerCase()] = false;});

// touch controls
let touchState = {left:false,right:false,swipeStartY:null};
canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  const t = e.touches[0];
  if(!t) return;
  const x = t.clientX;
  if(x < window.innerWidth/2) touchState.left = true; else touchState.right = true;
  touchState.swipeStartY = t.clientY;
});
canvas.addEventListener('touchmove', e=>{e.preventDefault();});
canvas.addEventListener('touchend', e=>{touchState.left=false;touchState.right=false;});

// ----- Camera & World -----
let cameraX = 0, cameraY = 0;

// ----- Entities -----
class Entity{constructor(x,y,w,h){this.x=x;this.y=y;this.w=w;this.h=h;}}
class Platform extends Entity{
  constructor(x,y,w,type='static',vx=0){super(x,y,w,20);this.type=type;this.vx=vx;this.color='#6fa';this.bump=false}
  update(dt){ if(this.type==='moving'){this.x += this.vx*dt; if(this.x < this._minX || this.x+this.w > this._maxX) this.vx *= -1;} }
}
class Enemy extends Entity{constructor(x,y){super(x,y,36,44);this.vx = -100;this.alive = true}}
class Collectible extends Entity{constructor(x,y){super(x,y,18,18);this.collected=false}}

// player
const player = {
  x:150, y:200, w:CONFIG.player.w, h:CONFIG.player.h,
  vx:220, vy:0, onGround:false, jumps:0, facing:1,
  dashing:false, dashTimer:0
};

// world arrays
let platforms = [], enemies = [], collectibles = [];
let furthestX = 0; // highest generated x
let score = 0;

// initial ground platform
platforms.push(new Platform(-2000, 520, 5000));
furthestX = 3000;

// Procedural generator
function generatePlatformsIfNeeded(){
  const spawnAhead = cameraX + W*1.5;
  while(furthestX < spawnAhead){
    const prevY = platforms.length ? platforms[platforms.length-1].y : 520;
    const gap = rand({min:CONFIG.platformMinGap,max:CONFIG.platformMaxGap});
    const width = rand({min:CONFIG.platformMinWidth,max:CONFIG.platformMaxWidth});
    const y = clamp(prevY + rand({min:-CONFIG.platformYVariance,max:CONFIG.platformYVariance}), 180, 560);
    const x = furthestX + gap;
    // sometimes spawn moving platforms
    if(Math.random() < 0.14){
      const p = new Platform(x,y,width,'moving', (Math.random()>0.5?1:-1)* (60 + Math.random()*160));
      p._minX = x - 120; p._maxX = x + 120;
      platforms.push(p);
    } else {
      platforms.push(new Platform(x,y,width,'static'));
    }
    // occasionally enemies and collectibles
    if(Math.random() < 0.18){ enemies.push(new Enemy(x + width*0.5, y-44)); }
    if(Math.random() < 0.22){ collectibles.push(new Collectible(x + Math.min(120,width-20), y-34)); }
    furthestX = x + width;
  }
}

// Clean up far-behind objects
function cleanupBehind(){
  const limit = cameraX - W;
  platforms = platforms.filter(p => p.x + p.w > limit);
  enemies = enemies.filter(e => e.x + e.w > limit && e.alive);
  collectibles = collectibles.filter(c => c.x + c.w > limit && !c.collected);
}

// collision helpers
function rectIntersect(a,b){ return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h); }

// ----- Game logic -----
let lastTs = 0;
function update(ts){
  if(!lastTs) lastTs = ts; const dt = Math.min((ts-lastTs)/1000, 1/15); lastTs = ts;

  // input
  let left = keys['arrowleft'] || keys['a'] || touchState.left;
  let right = keys['arrowright'] || keys['d'] || touchState.right;
  let jumpKey = keys['arrowup'] || keys['w'] || keys[' '];

  // double-tap/time-limited dash
  if((keys['shift'] || keys[' ']) && !player.dashing && player.vx !== 0){ player.dashing = true; player.dashTimer = CONFIG.player.dashDuration; }
  if(player.dashing){ player.dashTimer -= dt; if(player.dashTimer <= 0) player.dashing = false; }

  // horizontal movement
  const targetSpeed = player.dashing ? CONFIG.player.dashSpeed * player.facing : (right ? CONFIG.player.speed : (left ? -CONFIG.player.speed : 0));
  // simple acceleration
  const accel = 2800;
  player.vx = player.vx + clamp(targetSpeed - player.vx, -accel*dt, accel*dt);
  if(targetSpeed !== 0) player.facing = Math.sign(targetSpeed);

  // gravity
  player.vy += CONFIG.gravity * dt;
  player.y += player.vy * dt;
  player.x += player.vx * dt;

  // platform movement update
  platforms.forEach(p=>p.update(dt));

  // collision with platforms (simple AABB tile-ish)
  player.onGround = false;
  for(let p of platforms){
    if(player.x + player.w > p.x && player.x < p.x + p.w){
      // vertical collision check
      const prevBottom = player.y - player.vy*dt + player.h;
      const playerBottom = player.y + player.h;
      if(prevBottom <= p.y && playerBottom >= p.y && player.y + player.h - player.vy*dt <= p.y + 40){
        // landed
        player.y = p.y - player.h;
        player.vy = 0; player.onGround = true; player.jumps = 0;
      }
    }
  }

  // jumping (edge triggered)
  if((keys['arrowup'] || keys['w'] || keys[' ']) && !player._jumpHeld){
    if(player.onGround || player.jumps < CONFIG.player.maxJumps){
      player.vy = -CONFIG.player.jumpSpeed; player.jumps++; player.onGround=false;
    }
    player._jumpHeld = true;
  }
  if(!(keys['arrowup'] || keys['w'] || keys[' '])) player._jumpHeld = false;

  // enemies update
  for(let e of enemies){ e.x += e.vx*dt; if(rectIntersect(e,player)){ e.alive=false; score -= 120; } }

  // collectibles
  for(let c of collectibles){ if(!c.collected && rectIntersect(c,player)){ c.collected=true; score += 350; } }

  // update camera
  const cameraTargetX = player.x - 220;
  cameraX += (cameraTargetX - cameraX) * clamp(dt*5,0,1);
  cameraY = 0; // static vertical camera for now

  // generate & cleanup
  generatePlatformsIfNeeded(); cleanupBehind();

  // score: based on forward progress
  score = Math.max(score, Math.floor(player.x - 120));

  // simple death (falling off bottom)
  if(player.y > 2000){ resetToCheckpoint(); }
}

function resetToCheckpoint(){
  // place player at last safe platform
  const lastPlatform = platforms[0] || platforms[platforms.length-1];
  player.x = (lastPlatform && lastPlatform.x + 40) || 150;
  player.y = (lastPlatform && lastPlatform.y - player.h - 2) || 200;
  player.vx = 220; player.vy = 0;
  score = Math.floor(player.x - 120);
}

// ----- Rendering -----
function draw(){
  // clear
  ctx.clearRect(0,0,W,H);

  // background parallax
  const skyGrad = ctx.createLinearGradient(0,0,0,H);
  skyGrad.addColorStop(0,'#0f1b3a'); skyGrad.addColorStop(1,'#071028');
  ctx.fillStyle = skyGrad; ctx.fillRect(0,0,W,H);

  // distant mountains parallax
  ctx.save();
  ctx.translate(-cameraX*0.25,0);
  drawMountains();
  ctx.restore();

  // platforms
  for(let p of platforms){
    const drawX = Math.round(p.x - cameraX);
    const drawY = Math.round(p.y - cameraY);
    ctx.fillStyle = p.type === 'moving' ? '#7aa' : '#9ad';
    roundRect(ctx, drawX, drawY, Math.round(p.w), Math.round(p.h), 6, true, false);
    // top edge highlight
    ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(drawX+6, drawY+2, Math.max(4,p.w-12), 4);
  }

  
  // enemies
  for(let e of enemies){ if(!e.alive) continue; const dx = e.x - cameraX; ctx.fillStyle='#d86'; roundRect(ctx, Math.round(dx), Math.round(e.y), e.w, e.h, 6, true); }

  // collectibles
  for(let c of collectibles){ if(c.collected) continue; const dx = c.x - cameraX; const dy = c.y - cameraY; ctx.beginPath(); ctx.fillStyle='#ffd36b'; ctx.ellipse(dx+9,dy+9,9,9,0,0,Math.PI*2); ctx.fill(); }

  // player
  const px = player.x - cameraX; const py = player.y - cameraY;
  // shadow
  ctx.beginPath(); ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.ellipse(px+player.w/2, py+player.h+6, player.w*0.6, 8, 0,0,Math.PI*2); ctx.fill();
  // body
  ctx.save(); ctx.translate(px + player.w/2, py + player.h/2);
  ctx.scale(1,1);
  ctx.fillStyle = '#6bf'; roundRect(ctx, -player.w/2, -player.h/2, player.w, player.h, 8, true);
  // eye
  ctx.fillStyle='#012'; ctx.fillRect(player.facing>0?6:-12, -6, 6, 6);
  ctx.restore();

  // HUD
  document.getElementById('hud').textContent = `Score: ${Math.floor(score)}`;
}


function drawMountains(){
  ctx.fillStyle = '#081530'; ctx.beginPath(); ctx.moveTo(0,420); ctx.lineTo(140,260); ctx.lineTo(260,420); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(240,420); ctx.lineTo(420,200); ctx.lineTo(620,420); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(560,420); ctx.lineTo(760,300); ctx.lineTo(960,420); ctx.closePath(); ctx.fill();
}


function roundRect(ctx,x,y,w,h,r,fill,stroke){ if(typeof r==='undefined') r=5; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); if(stroke) ctx.stroke(); }

// ----- Main Loop -----
function loop(ts){ update(ts); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

// ----- Debug & Extras -----
// simple pause / resume by clicking canvas
let paused = false; canvas.addEventListener('click', ()=>{ paused = !paused; if(!paused){ lastTs = 0; requestAnimationFrame(loop); } });


// allow window focus/blur stop
window.addEventListener('blur', ()=>{});


// small helper to show FPS & tune difficulty (not drawn onscreen)

// Expose some functions for quick tuning in console
window._game = {player,platforms,enemies,collectibles,CONFIG,resetToCheckpoint};


</script>
</body>
</html>